<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>单片机笔记 | 璃雲の部屋</title><meta name="author" content="Rikumo.Rinnku"><meta name="copyright" content="Rikumo.Rinnku"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概述学习目标  预备知识 单片机:单片微型计算机 CPU时序: 单片机内的取指、分析、执行等各种操作都是在一系列时钟脉冲控制下进行的，而各脉冲在时间上是有先后顺序的，这种顺序就称为时序。  1.1 ARM概述1.1.1  	ARM 简介 ARM两个显著特点: ARM既是一个公司的名称，也是一类微处理器的通称。 由苹果电脑，Acorn电脑，VLSI技术（公司）合资，1990年成立于英国剑桥，主要出售">
<meta property="og:type" content="article">
<meta property="og:title" content="单片机笔记">
<meta property="og:url" content="http://rikumo-rinnku.github.io/%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="璃雲の部屋">
<meta property="og:description" content="概述学习目标  预备知识 单片机:单片微型计算机 CPU时序: 单片机内的取指、分析、执行等各种操作都是在一系列时钟脉冲控制下进行的，而各脉冲在时间上是有先后顺序的，这种顺序就称为时序。  1.1 ARM概述1.1.1  	ARM 简介 ARM两个显著特点: ARM既是一个公司的名称，也是一类微处理器的通称。 由苹果电脑，Acorn电脑，VLSI技术（公司）合资，1990年成立于英国剑桥，主要出售">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E6%B0%B4%E5%A1%94.jpg">
<meta property="article:published_time" content="2024-03-20T05:07:45.187Z">
<meta property="article:modified_time" content="2024-03-20T05:08:05.356Z">
<meta property="article:author" content="Rikumo.Rinnku">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E6%B0%B4%E5%A1%94.jpg"><link rel="shortcut icon" href="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E7%99%BD%E6%AF%9B%E5%90%B8%E8%A1%80%E9%AC%BC.png"><link rel="canonical" href="http://rikumo-rinnku.github.io/%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '单片机笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-20 13:08:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E7%99%BD%E6%AF%9B%E5%90%B8%E8%A1%80%E9%AC%BC.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E6%B0%B4%E5%A1%94.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">璃雲の部屋</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">单片机笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-20T05:07:45.187Z" title="发表于 2024-03-20 13:07:45">2024-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-20T05:08:05.356Z" title="更新于 2024-03-20 13:08:05">2024-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%B0%E5%BD%95/">记录</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="单片机笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210112039980.png">

<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul>
<li>单片机:单片微型计算机</li>
<li>CPU时序: 单片机内的取指、分析、执行等各种操作都是在一系列时钟脉冲控制下进行的，而各脉冲在时间上是有先后顺序的，这种顺序就称为时序。</li>
</ul>
<h2 id="1-1-ARM概述"><a href="#1-1-ARM概述" class="headerlink" title="1.1 ARM概述"></a>1.1 ARM概述</h2><h3 id="1-1-1-ARM-简介"><a href="#1-1-1-ARM-简介" class="headerlink" title="1.1.1  	ARM 简介"></a>1.1.1  	ARM 简介</h3><ul>
<li>ARM两个显著特点:<ul>
<li><p>ARM既是一个公司的名称，也是一类微处理器的通称。</p>
<pre><code>由苹果电脑，Acorn电脑，VLSI技术（公司）合资，1990年成立于英国剑桥，主要出售芯片设计技术的授权。
</code></pre>
</li>
<li><p>ARM既是一种技术的名称，也是一种商业思想&#x2F;模式。</p>
</li>
</ul>
</li>
<li>ARM Cortex-M3<ul>
<li>ARMv7内核处理器</li>
<li>简称CM3</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-ARM-的RISC体系结构"><a href="#1-1-2-ARM-的RISC体系结构" class="headerlink" title="1.1.2  	ARM 的RISC体系结构"></a>1.1.2  	ARM 的RISC体系结构</h3><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210112039127.png" alt="CISC与RISC">

<p>其中RISC与CISC各有优势</p>
<p>到目前为止，RISC 体系结构还没有严格的定义，一般认为，RISC 体系结构应具有如下特点：</p>
<ul>
<li>指令格式长度固定、归整、简单、基本寻址方式有 2～3 种。</li>
<li>使用单周期指令，便于流水线操作执行。</li>
<li>大量使用寄存器，数据处理指令只用寄存器，访问存储器用加载&#x2F;存储指令</li>
</ul>
<h3 id="1-1-3-ARM-的各种构架版本"><a href="#1-1-3-ARM-的各种构架版本" class="headerlink" title="1.1.3  	ARM 的各种构架版本"></a>1.1.3  	ARM 的各种构架版本</h3><ul>
<li>学习的是ARMv7<ul>
<li>采用了Thunmb-2技术</li>
<li>定义3种内核 :<ul>
<li>A：面向应用的微处理器，针对复杂操作系统和应用程序设计；</li>
<li>R：针对实时系统的嵌入式处理器</li>
<li>M：针对成本敏感应用优化的深度嵌入式处理器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-1-4-ARM-处理器的命名法则"><a href="#1-1-4-ARM-处理器的命名法则" class="headerlink" title="1.1.4  	ARM 处理器的命名法则"></a>1.1.4  	ARM 处理器的命名法则</h3><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210112040441.png">

<h3 id="1-1-5ARM-的各系列CPU"><a href="#1-1-5ARM-的各系列CPU" class="headerlink" title="1.1.5	ARM 的各系列CPU"></a>1.1.5	ARM 的各系列CPU</h3><p>除了ARM7还要学习Cortex系列<br><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210112040098.png"></p>
<hr>
<h2 id="1-2-Cortex-M3概述"><a href="#1-2-Cortex-M3概述" class="headerlink" title="1.2 Cortex-M3概述"></a>1.2 Cortex-M3概述</h2><p>Cortex-M3 简称CM3,完整的CM3 MCU(微型控制单元)就是CM3内核+其他组件,如:</p>
<img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210112041280.png">

<h3 id="1-2-1Cortex-M3处理器的结构"><a href="#1-2-1Cortex-M3处理器的结构" class="headerlink" title="1.2.1	Cortex-M3处理器的结构"></a>1.2.1	Cortex-M3处理器的结构</h3><ul>
<li><p>32位处理器内核,哈弗体系结构</p>
<ul>
<li>位内部数据路径，32 位寄存器，32 位存储器接口</li>
<li>拥有独立的<strong>指令总线</strong>和<strong>数据总线</strong>(这个就是指哈弗结构)，可并行取指与访问数据，数据访问<strong>不占用指令总线</strong>，提升了性能。</li>
</ul>
</li>
<li><p>大小端格式的数据存储</p>
<ul>
<li>小端格式:低字节字数据存放在低地址，高字节字数据存放在高地址存储器中.<strong>通常来说CM3采用小端格式</strong></li>
<li>大端格式:与小端相反</li>
</ul>
</li>
</ul>
<h3 id="1-2-2Cortex-M3处理器的特点"><a href="#1-2-2Cortex-M3处理器的特点" class="headerlink" title="1.2.2	Cortex-M3处理器的特点"></a>1.2.2	Cortex-M3处理器的特点</h3><p>特点:</p>
<ul>
<li>分为内核和高级系统外设,称为<strong>分级处理器</strong></li>
<li>CM3处理器<ul>
<li><p>Cortex-M3 内核</p>
<ul>
<li>哈佛体系结构</li>
<li>拥有分支预测功能的三级流水线  </li>
<li>Thumb®-2 指令集和传统的 Thumb指令集</li>
<li>带有 硬件除法和 单信号周期乘法的ALU</li>
<li>支持两种状态：Thumb 和调试状态</li>
</ul>
</li>
<li><p>可配置的中断控制器 </p>
</li>
<li><p>总线矩阵</p>
</li>
<li><p>先进的调试组件 </p>
</li>
<li><p>可选择的 MPU &amp; ETM</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-3Cortex-M3可配置的选项"><a href="#1-2-3Cortex-M3可配置的选项" class="headerlink" title="1.2.3	Cortex-M3可配置的选项"></a>1.2.3	Cortex-M3可配置的选项</h3><ul>
<li>1 中断<ul>
<li>外部中断可配置1-240个</li>
<li>中断优先级可配置3-8个</li>
</ul>
</li>
<li>2 存储器管理单元(MPU)<ul>
<li>1个</li>
</ul>
</li>
<li>3 嵌入式跟踪宏单元(ETM)<ul>
<li>1个</li>
</ul>
</li>
</ul>
<h3 id="1-2-4Cortex-M3指令集"><a href="#1-2-4Cortex-M3指令集" class="headerlink" title="1.2.4	Cortex-M3指令集"></a>1.2.4	Cortex-M3指令集</h3><h4 id="1-ARM的指令集有三个"><a href="#1-ARM的指令集有三个" class="headerlink" title="1) ARM的指令集有三个"></a>1) ARM的指令集有三个</h4><ul>
<li>32位ARM指令集<ul>
<li>对应处理器的ARM状态</li>
</ul>
</li>
<li>16位Thumb指令集<ul>
<li>ARM指令集子集</li>
<li>对应处理器的Thumb状态</li>
</ul>
</li>
</ul>
<blockquote>
<p>这两种指令集对应两种处理器执行状态。处理器可以在两种执行状态之间动态切换。尽管切换开销很大，但能带来更高的代码密度，给目标代码减肥。</p>
</blockquote>
<ul>
<li>Thumb-2指令集体系结构（ISA）<ul>
<li>Thumb指令集的一个超集</li>
</ul>
</li>
</ul>
<blockquote>
<p>Thumb‐2首次实现16位与32位指令并存，结果在Thumb状态下，同样工作需要的指令周期数明显下降。</p>
</blockquote>
<p>那么我们学习的Cortex-M3的指令集使用的就是<strong>Thumb‐2的一种子集</strong>.</p>
<h4 id="2-Cortex-M3的指令集"><a href="#2-Cortex-M3的指令集" class="headerlink" title="2) Cortex-M3的指令集"></a>2) Cortex-M3的指令集</h4><ul>
<li>Cortex‐M3不是向后兼容的，ARM7的ARM汇编程序不能直接移植上CM3。</li>
<li>Cortex‐M3支持绝大多数传统的Thumb指令。</li>
<li>Cortex‐M3支持16位和32位指令，可自如在Thumb和ARM之间切换状态。这种切换在ARM7和ARM9是司空见惯的，尤其是在使用大型条件嵌套，以及执行复杂运算的时候，那可是要下大功夫的。</li>
<li><u><strong>Cortex‐M3破天荒地支持了“非对齐数据访问”。</strong></u></li>
</ul>
<h4 id="3-Cortex-M3-与三种指令集的关系"><a href="#3-Cortex-M3-与三种指令集的关系" class="headerlink" title="3) Cortex-M3 与三种指令集的关系"></a>3) Cortex-M3 与三种指令集的关系</h4><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210112041862.png" alt="Cortex-M3 与三种指令集的关系">

<h2 id="1-3-STM32概述"><a href="#1-3-STM32概述" class="headerlink" title="1.3 STM32概述"></a>1.3 STM32概述</h2><p>STM32是意法半导体的基于<strong>ARM® Cortex®-M0、M0+、M3、M4、M33、M7、A7内核</strong>并具备丰富外设选择的32位微控制器及微处理器。</p>
<h3 id="1-3-1STM32的分类"><a href="#1-3-1STM32的分类" class="headerlink" title="1.3.1	STM32的分类"></a>1.3.1	STM32的分类</h3><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210112042028.png">

<h3 id="1-3-2STM32的命名规则"><a href="#1-3-2STM32的命名规则" class="headerlink" title="1.3.2	STM32的命名规则"></a><strong>1.3.2	STM32的命名规则</strong></h3><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210112042474.png">

<h3 id="1-3-3STM32F1的命名规则"><a href="#1-3-3STM32F1的命名规则" class="headerlink" title="1.3.3	STM32F1的命名规则"></a>1.3.3	STM32F1的命名规则</h3><h3 id="1-3-4STM32F1系列MCU分类与选型"><a href="#1-3-4STM32F1系列MCU分类与选型" class="headerlink" title="1.3.4	STM32F1系列MCU分类与选型"></a>1.3.4	STM32F1系列MCU分类与选型</h3><h3 id="1-3-5芯片封装与管腿描述"><a href="#1-3-5芯片封装与管腿描述" class="headerlink" title="1.3.5	芯片封装与管腿描述"></a>1.3.5	芯片封装与管腿描述</h3><h3 id="1-3-6STM32F1系列MCU的性能特点"><a href="#1-3-6STM32F1系列MCU的性能特点" class="headerlink" title="1.3.6	STM32F1系列MCU的性能特点"></a>1.3.6	STM32F1系列MCU的性能特点</h3><h3 id="1-3-7STM32的固件库与开发工具"><a href="#1-3-7STM32的固件库与开发工具" class="headerlink" title="1.3.7	STM32的固件库与开发工具"></a>1.3.7	STM32的固件库与开发工具</h3><h1 id="ARM-CM3的指令系统"><a href="#ARM-CM3的指令系统" class="headerlink" title="ARM CM3的指令系统"></a>ARM CM3的指令系统</h1><h2 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h2><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210112043653.png">

<h2 id="2-2工作模式和访问权限"><a href="#2-2工作模式和访问权限" class="headerlink" title="2.2工作模式和访问权限"></a>2.2工作模式和访问权限</h2><h3 id="一-前提概念-异常"><a href="#一-前提概念-异常" class="headerlink" title="一. 前提概念: 异常"></a>一. 前提概念: 异常</h3><p><font color="aqua">在ARM 中，凡是打断程序顺序执行的事件，都被称为异常。</font></p>
<ul>
<li>ARM异常包括：外部中断外，指令执行“非法操作”，访问被禁内存区间，各种错误产生的故障，不可屏蔽中断等。</li>
<li>在不严格的上下文中，异常与中断也可以混用。</li>
<li>程序代码也可以主动请求进入异常状态的（常用于系统调用）。</li>
</ul>
<h3 id="二-两种工作模式"><a href="#二-两种工作模式" class="headerlink" title="二.两种工作模式"></a>二.两种工作模式</h3><ul>
<li><p>处理模式:用于执行异常处理例程的处理器工作模式</p>
</li>
<li><p>线程模式:用于执行主应用程序的处理器工作模式</p>
</li>
<li><p>目的:用于区别<strong>普通应用代码</strong>和异常例程代码</p>
</li>
</ul>
<h3 id="三-两种访问权限-特权级别"><a href="#三-两种访问权限-特权级别" class="headerlink" title="三.两种访问权限(特权级别)"></a>三.两种访问权限(特权级别)</h3><ul>
<li>特权级: 可以访问任意资源、执行任何指令</li>
<li>用户级: 不能访问有限制或被禁止的资源</li>
<li>目的: 提供一种资源访问的保护机制，防止普通用户代码或意外、或恶意地执行要害操作.是构成一个硬件层上的<strong>基本安全模型</strong></li>
</ul>
<h3 id="四-工作模式与访问权限的关系"><a href="#四-工作模式与访问权限的关系" class="headerlink" title="四. 工作模式与访问权限的关系"></a>四. 工作模式与访问权限的关系</h3><p><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210242126538.png" alt="image-20221024212634504"></p>
<h2 id="2-3工作模式、访问权限的转换"><a href="#2-3工作模式、访问权限的转换" class="headerlink" title="2.3工作模式、访问权限的转换"></a>2.3工作模式、访问权限的转换</h2><h3 id="访问权限转换途径"><a href="#访问权限转换途径" class="headerlink" title="访问权限转换途径"></a>访问权限转换途径</h3><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210242144969.png" alt="image-20221024214456922" style="zoom:67%;">

<ol>
<li><p>复位后<a href="%E5%B0%B1%E6%98%AF%E5%8D%95%E7%89%87%E6%9C%BA%E6%81%A2%E5%A4%8D%E5%87%BA%E5%8E%82%E8%AE%BE%E7%BD%AE">^1</a>，CM3默认进入：<font color="FF7744"><strong>线程模式</strong></font> + <font color="aqua"><strong>特权级</strong></font></p>
</li>
<li><p>主应用程序运行<font color="FF7744"><strong>线程模式</strong></font>下，可使用<font color="aqua"><strong>特权级</strong></font>或<font color="aqua"><strong>用户级</strong></font></p>
</li>
<li><p>异常处理例程运行在<font color="FF7744"><strong>处理模式</strong></font>下，必须使用*<font color="aqua"><strong>特权级</strong></font></p>
</li>
<li><p>从<font color="aqua"><strong>特权级</strong></font>切换到<font color="aqua"><strong>用户级</strong></font>，修改<code>CONTROL</code>寄存器<a href="%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8">^2</a>即可</p>
</li>
<li><p>从<font color="aqua"><strong>用户级</strong></font>切换回<font color="aqua"><strong>特权级</strong></font>模式，必须执行一条系统调用指令<code>SVC</code>，触发<code>SVC</code>异常，在异常处理例程中修改<code>CONTROL</code>才能回到特权级<br><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210242142050.png" alt="image-20221024214243009"></p>
</li>
<li><p><font color="FF7744"><strong>处理模式</strong></font>下，执行异常退出，则返回<font color="FF7744"><strong>线程模式</strong></font></p>
</li>
<li><p><font color="FF7744"><strong>线程模式</strong></font>下，触发异常转入<font color="FF7744"><strong>处理模式</strong></font></p>
</li>
</ol>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>线程模式下为什么不能从 <strong>用户级权限</strong> 直接返回到 <strong>特权级权限</strong>？</p>
<ul>
<li>原因<ul>
<li>用户级权限有限<ul>
<li>禁止访问系统控制空间(SCS)<ul>
<li>包含配置寄存器 </li>
<li>调试组件寄存器</li>
</ul>
</li>
<li>禁止MSR 访问特殊功能(寄存器–除有APSR 例外)</li>
<li>访问了就是FAULT</li>
</ul>
</li>
</ul>
</li>
<li>方法<ul>
<li>从特权级进入用户级只用置位<code>CONTROL[0]</code>即可,但是不能反过来,那么可以通过触发一个（软）中断，再由服务例程改写该位，才能在返回到线程模式后拿到特权级。(唯一途径)</li>
</ul>
</li>
</ul>
<h2 id="2-4数据类型与存储器格式"><a href="#2-4数据类型与存储器格式" class="headerlink" title="2.4数据类型与存储器格式"></a>2.4数据类型与存储器格式</h2><h3 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一. 数据类型"></a>一. 数据类型</h3><p><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210242152287.png" alt="image-20221024215218252"></p>
<h3 id="二-储存器格式"><a href="#二-储存器格式" class="headerlink" title="二. 储存器格式"></a>二. 储存器格式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li><p>Cortex-M3 处理器存储器的地址是从0 开始向上编号的字节的线性集合。例如：</p>
<ul>
<li>字节 0-3 存放第一个字，字节 4-7 存放第二个字</li>
</ul>
</li>
<li><p>Cortex-M3 处理器支持<font color="ff7744"><em>小端格式</em></font>或<font color="ff7744"><em>大端格式</em></font>存储器数据字的访问。</p>
</li>
<li><h6 id="ARM-处理器默认的小端存储器格式，访问代码始终使用小端格式。"><a href="#ARM-处理器默认的小端存储器格式，访问代码始终使用小端格式。" class="headerlink" title="ARM 处理器默认的小端存储器格式，访问代码始终使用小端格式。"></a><font color="red"><strong>ARM 处理器默认的小端存储器格式，访问代码始终使用小端格式。</strong></font></h6></li>
<li><p>Cortex-M3 处理器可以通过配置管脚 <strong>BIGEND</strong>，来选择<font color="ff7744">小端格式</font> 或<font color="ff7744">BE-8 大端格式</font>。该管脚在复位时被采样，结束复位后存储器格式不能修改。</p>
</li>
<li><p>注：</p>
<ul>
<li>对系统控制空间（SCS）的访问始终采用小端格式。</li>
<li>在非复位的状态下试图改变存储器格式的操作将被忽略。</li>
<li>专用外设总线（PPB）空间只能为小端格式，<strong>BIGEND</strong> 的设置无效。</li>
</ul>
</li>
</ul>
<h4 id="2-大、小端数据格式"><a href="#2-大、小端数据格式" class="headerlink" title="2.大、小端数据格式"></a>2.大、小端数据格式</h4><ul>
<li>小端数据格式:<strong>数据高位存入高地址，数据低位存入低地址</strong></li>
<li>大端数据格式:<strong>数据低位存入高地址，数据高位存入低地址。</strong><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210251944643.png" alt="image-20221025194409558" style="zoom:67%;"></li>
</ul>
<h2 id="2-5寄存器"><a href="#2-5寄存器" class="headerlink" title="2.5寄存器"></a>2.5寄存器</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>寄存器类型<ul>
<li>通用寄存器<ul>
<li>R0-R12</li>
<li>R13、R14、R15</li>
</ul>
</li>
<li>特殊功能寄存器<ul>
<li>程序状态寄存器组</li>
<li>中断屏蔽寄存器组</li>
<li>控制寄存器</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210251951232.png" alt="image-20221025195102180"></p>
<h3 id="一-通用寄存器-R0-R15"><a href="#一-通用寄存器-R0-R15" class="headerlink" title="一. 通用寄存器 R0-R15"></a>一. 通用寄存器 R0-R15</h3><p>从图上可以看出分为低组和高组,绝大多数16 位Thumb 指令只能访问低组寄存器–R0‐R7,高组寄存器R8-R12，只有少量16 位Thumb 指令能访问,而32 位Thumb‐2 指令可以访问所有寄存器。另外,R0-R12仅作通用寄存器使用,R13-R15不仅可作通用寄存器,还有特殊功能。还有,复位后,寄存器初始值不可确定,无论高低组。</p>
<h4 id="1-堆栈指针寄存器R13-SP"><a href="#1-堆栈指针寄存器R13-SP" class="headerlink" title="1. 堆栈指针寄存器R13(SP)"></a>1. 堆栈指针寄存器R13(SP)</h4><blockquote>
<p>关于栈和R13的推荐阅读[^3]</p>
</blockquote>
<ul>
<li>分组的堆栈寄存器，含两个堆栈指针，任一时刻只能使用一个。</li>
<li>当引用R13（或写作SP）时，引用到的是当前正在使用的那一个，另一个必须用特殊的指令来访问(<code>MRS</code>，<code>MSR</code> 指令)。</li>
<li>Cortex-M3支持2个堆栈，都指向R13<ul>
<li>主堆栈MSP：别名为<code>SP_main </code>，复位后缺省的堆栈指针，系统内核、异常、特权访问时使用。</li>
<li>进程堆栈PSP：别名<code>SP_process</code>，由用户的应用程序代码使用。</li>
<li><strong>堆栈指针的最低两位永远是0，堆栈总是<font color="aqua">4 字节对齐</font>的。</strong></li>
<li>不要求每个应用必须用齐两个堆栈指针。简单的应用程序只使用<code>MSP</code>就够了，<code>PUSH</code> 和<code>POP </code>指令默认使用<code>SP</code>。<img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210252021800.png" alt="image-20221025202155767"></li>
</ul>
</li>
</ul>
<h4 id="2-链接寄存器R14（LR）"><a href="#2-链接寄存器R14（LR）" class="headerlink" title="2. 链接寄存器R14（LR）"></a>2. 链接寄存器R14（LR）</h4><ul>
<li>R14 用于保存子程序调用和异常的<strong>返回地址</strong>。</li>
<li><strong>R14 保存的是当前正在执行的指令的_一下条指令的地址_，LR的值_自动填充_。</strong></li>
<li>因为代码至少是字对齐的，所以PC的LSB(有效最低位)始终为0。但LR的LSB可读&#x2F;写，这是历史遗留产物。以前，因为有些ARM芯片同时支持ARM状态和Thumb状态，要由LR的第0位来指示ARM&#x2F;Thumb状态。为方便程序移植，CM3允许LR的LSB位可读&#x2F;可写。</li>
</ul>
<h4 id="3-程序计数器R15（PC）"><a href="#3-程序计数器R15（PC）" class="headerlink" title="3.程序计数器R15（PC）"></a>3.程序计数器R15（PC）</h4><ul>
<li><p>指向当前正在取指的指令地址。如果修改它的值，就能改变程序的执行流</p>
</li>
<li><p>CM3内部使用了三级指令流水线，读PC时返回值是当前指令地址+4</p>
<blockquote>
<p>例如：0x1000: MOV R0, PC ; R0 &#x3D; 0x1004</p>
</blockquote>
</li>
<li><p>CM3中的指令至少是半字对齐 的，所以PC的最低有效位总是读回0</p>
</li>
<li><p>在分支时，无论是直接写PC 的值还是使用分支指令，都必须保证加载到PC 的数值是奇数（即LSB&#x3D;1），用以表明这是在Thumb 状态下执行。倘若写了0，则视为企图转入ARM 模式，CM3 将产生一个fault 异常</p>
</li>
</ul>
<h3 id="二-特殊功能寄存器"><a href="#二-特殊功能寄存器" class="headerlink" title="二. 特殊功能寄存器"></a>二. 特殊功能寄存器</h3><blockquote>
<p>特殊功能的意思就是说在设计之初就是定死的,往往不能后续改变</p>
</blockquote>
<h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><img src="http://rjkiaj1fv.hd-bkt.clouddn.com/img/202210252058211.png" alt="image-20221025205833150" style="zoom:67%;">

<ul>
<li><p>程序状态寄存器组 xPSR	</p>
<ul>
<li>应用程序状态寄存器（APSR）</li>
<li>中断号程序状态寄存器（IPSR）</li>
<li>执行程序状态寄存器（EPSR）</li>
</ul>
</li>
<li><p>中断屏蔽寄存器组</p>
<ul>
<li>中断屏蔽寄存器PRIMASK</li>
<li>异常关闭寄存器FAULTMASK</li>
<li>中断优先级屏蔽寄存器BASEPRI</li>
</ul>
</li>
<li><p>控制寄存器CONTROL</p>
</li>
<li><p>特殊功能寄存器有预定义的功能必须用专门指令来访问。</p>
</li>
<li><p>特殊功能寄存器没有存储器地址，只能被专用的<code>MSR </code>和<code>MRS </code>指令访问，访问格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRS &lt;gp_reg&gt;, &lt;special_reg&gt; ;读特殊功能寄存器的值到通用寄存器</span><br><span class="line">MSR &lt;special_reg&gt;, &lt;gp_reg&gt; ;写通用寄存器的值到特殊功能寄存器</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="一-程序状态寄存器（PSRs-或xPSR）"><a href="#一-程序状态寄存器（PSRs-或xPSR）" class="headerlink" title="一. 程序状态寄存器（PSRs 或xPSR）"></a>一. 程序状态寄存器（PSRs 或xPSR）</h3><h4 id="1-应用程序状态寄存器APSR"><a href="#1-应用程序状态寄存器APSR" class="headerlink" title="1. 应用程序状态寄存器APSR"></a>1. 应用程序状态寄存器APSR</h4><h4 id="2-中断号程序状态寄存器IPSR"><a href="#2-中断号程序状态寄存器IPSR" class="headerlink" title="2. 中断号程序状态寄存器IPSR"></a>2. 中断号程序状态寄存器IPSR</h4><h4 id="3-执行程序状态寄存器EPSR"><a href="#3-执行程序状态寄存器EPSR" class="headerlink" title="3. 执行程序状态寄存器EPSR"></a>3. 执行程序状态寄存器EPSR</h4><h2 id="2-6异常与中断"><a href="#2-6异常与中断" class="headerlink" title="2.6异常与中断"></a>2.6异常与中断</h2><h2 id="2-7向量表"><a href="#2-7向量表" class="headerlink" title="2.7向量表"></a>2.7向量表</h2><h2 id="2-8堆栈操作"><a href="#2-8堆栈操作" class="headerlink" title="2.8堆栈操作"></a>2.8堆栈操作</h2><h2 id="2-9复位序列"><a href="#2-9复位序列" class="headerlink" title="2.9复位序列"></a>2.9复位序列</h2><p>[^3]: <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38233274/article/details/82714036">(23条消息) ARM堆栈指针sp(r13)详解_Leo丶Fun的博客-CSDN博客_arm sp指针</a></p>
<h1 id="第-3-章-ARM-Cortex-M3的指令系统"><a href="#第-3-章-ARM-Cortex-M3的指令系统" class="headerlink" title="第 3 章 ARM-Cortex-M3的指令系统"></a>第 3 章 ARM-Cortex-M3的指令系统</h1><h2 id="3-2-Cortex-M3的八种寻址方式"><a href="#3-2-Cortex-M3的八种寻址方式" class="headerlink" title="3.2 Cortex-M3的八种寻址方式"></a>3.2 Cortex-M3的八种寻址方式</h2><p>Cortex-M3的指令格式—ARM的三地址指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">标号 &lt;Opcode&gt; &#123;&lt;Cond&gt;&#125;&#123;S&#125;&#123;.N|.W&#125; &lt;Rd&gt;,&lt;Rn&gt;[,&lt;Operand2&gt;];注释</span><br><span class="line"></span><br><span class="line">标号 &lt;操作码&gt; &#123;条件码&#125; &lt;第一操作数&gt;,&lt;第二操作数&gt;[,&lt;第三操作数&gt;];注释</span><br><span class="line"></span><br><span class="line">标号 &lt;指令码&gt; &#123;条件码&#125; &lt;目标寄存器&gt;,&lt;源寄存器1&gt; [,&lt;源寄存器2&gt;];注释(通常来说)</span><br></pre></td></tr></table></figure>
<h3 id="1、寄存器寻址"><a href="#1、寄存器寻址" class="headerlink" title="1、寄存器寻址"></a>1、寄存器寻址</h3><blockquote>
<p>指令中的地址码字段（第一或第二操作数）给出的是寄存器编号，操作数的值在寄存器中，指令执行时直接取出寄存器值来操作。例：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV  R1,R2; 将R2的值存入R1 </span><br><span class="line"></span><br><span class="line">SUB  R0,R1,R2  ;将R1的值减去R2的值，结果存R0 </span><br></pre></td></tr></table></figure>
<h3 id="2、立即寻址"><a href="#2、立即寻址" class="headerlink" title="2、立即寻址"></a>2、立即寻址</h3><p>直接把整数作为地址给寄存器</p>
<blockquote>
<p>地址码字段（第一或第二操作数）直接给出是一整数（称立即数），例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUBS R0,R0,#1;  R0减1结果放入R0，影响标志位</span><br><span class="line">MOV R0,#0xFF000; 将立即数0xFF000装入R0</span><br></pre></td></tr></table></figure>
<h3 id="3、寄存器移位寻址"><a href="#3、寄存器移位寻址" class="headerlink" title="3、寄存器移位寻址"></a>3、寄存器移位寻址</h3><blockquote>
<p>地址码字段（第一或第二操作数）在操作之前，先进行移位操作。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV	R0,R2,LSL #3 ;R2的值左移3位，结果存R0，相当如R0=R2*8.</span><br><span class="line"></span><br><span class="line">ANDS R1,R1,R2,LSL R3  ;R2的值左移R3位，再和R1相“与”操作，结果放入R1</span><br></pre></td></tr></table></figure>

<ul>
<li>可采用的移位操作<ul>
<li>LSL逻辑左移（Logical Shift Left）：寄存器中数据位低端空出的位补0；</li>
<li>LSR逻辑右移（Logical Shift Right）：寄存器中数据位高端空出的位补0；</li>
<li>ASR算术右移（Arithmetic Shift Right）：移位过程中保持符号位不变，即若源操作数为正数，则数据位的高端空出的位补0，否则补1；</li>
<li>ROR循环右移（Rotate Right）：由数据位的低端移出的位填入数据位的高端空出的位；</li>
<li>RRX带扩展的循环右移（Rotate Right eXtended by 1 place）：操作数右移一位，高端空出的位用原C标志值填充。</li>
</ul>
</li>
</ul>
<h3 id="4、寄存器间接寻址"><a href="#4、寄存器间接寻址" class="headerlink" title="4、寄存器间接寻址"></a>4、寄存器间接寻址</h3><blockquote>
<p>地址码字段（第一或第二操作数）给出的是一个通用寄存器的编号，所需的操作数保存在寄存器指定地址的存储单元中，即寄存器为操作数的地址指针，例： </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR R1,[R2] ; 将R2指向的存储单元的数据读出存R1.(这里的R2相当于指针)</span><br></pre></td></tr></table></figure>


<h3 id="5、基址寻址"><a href="#5、基址寻址" class="headerlink" title="5、基址寻址"></a>5、基址寻址</h3><blockquote>
<p>就是将基址寄存器的内容与给出的偏移量相加，形成操作数的有效地址。用于查表、数组操作、功能部件寄存器访问等。例：</p>
</blockquote>
<p>实际上也是间接寻址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR R2,[R3,#0x0C]   ;读(R3)+0x0C地址上的存储单元的值存R2 </span><br></pre></td></tr></table></figure>

<h3 id="6、多寄存器寻址"><a href="#6、多寄存器寻址" class="headerlink" title="6、多寄存器寻址"></a>6、多寄存器寻址</h3><blockquote>
<p>多寄存器寻址一次可传送几个寄存器值，允许一条指令传送16个寄存器的任何子集或所有寄存器。</p>
</blockquote>
<p>最多就16个寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDMIA R1!,&#123;R2-R4,R6&#125;; 将R1指向单元中的数据存到R2～R4、R6中(R1自动加4) 先存储在增加</span><br></pre></td></tr></table></figure>

<h3 id="7、堆栈寻址"><a href="#7、堆栈寻址" class="headerlink" title="7、堆栈寻址"></a>7、堆栈寻址</h3><blockquote>
<ul>
<li>堆栈是一个按特定顺序进行存取的存储区，后进先出。</li>
<li>堆栈寻址是隐含的，使用一个专门的寄存器–堆栈指针SP，指向堆栈的存储单元即栈顶</li>
<li>按堆栈指针生长方式可分为：向上生长与向下生长的堆栈：</li>
</ul>
</blockquote>


<ul>
<li>注意增长方向与栈顶的位置</li>
<li>压栈就是加入数据</li>
</ul>
<hr>
<ul>
<li>堆栈分类<ul>
<li>按堆栈指向的位置可分为：满堆栈和空堆栈</li>
<li>满堆栈:堆栈指针指向最后压入的有效数据项</li>
<li>空堆栈:堆栈指针指向下一个待压入数据的空位置</li>
</ul>
</li>
<li>堆栈方式<ul>
<li><p>向上生长的满栈</p>
<pre><code>Cortex-M3向下生长的满栈模型
</code></pre>
</li>
<li><p>向上生长的空栈</p>
</li>
<li><p>向下生长的满栈</p>
</li>
<li><p>向下生长的空栈</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STMDB SP!, &#123;R1-R7, LR&#125; ; 将R1～R7、LR 入栈</span><br><span class="line">LDMIA SP!, &#123;R1-R7, PC&#125; ; 出栈，到R1～R7、LR 寄存器</span><br></pre></td></tr></table></figure>

<h3 id="8、相对寻址"><a href="#8、相对寻址" class="headerlink" title="8、相对寻址"></a>8、相对寻址</h3><blockquote>
<p>相对寻址是基址寻址的一种变通。由程序计数器PC提供基准地址，指令中的地址码字段作为偏移量，两者相加后得到的地址即为操作数的有效地址.</p>
</blockquote>
<h2 id="3-3-Thumb-2-汇编程序结构"><a href="#3-3-Thumb-2-汇编程序结构" class="headerlink" title="3.3 Thumb-2 汇编程序结构"></a>3.3 Thumb-2 汇编程序结构</h2>

<p>由两个部分组成:代码段+数据段</p>
<h2 id="3-4-Thumb-2指令基本格式"><a href="#3-4-Thumb-2指令基本格式" class="headerlink" title="3.4 Thumb-2指令基本格式"></a>3.4 Thumb-2指令基本格式</h2><h3 id="1-指令基本格式"><a href="#1-指令基本格式" class="headerlink" title="1.指令基本格式"></a>1.指令基本格式</h3>

<h2 id="3-5-Cortex-M3常用的Thumb-2指令"><a href="#3-5-Cortex-M3常用的Thumb-2指令" class="headerlink" title="3.5 Cortex-M3常用的Thumb-2指令"></a>3.5 Cortex-M3常用的Thumb-2指令</h2><h3 id="3-5-1-数据传送类指令"><a href="#3-5-1-数据传送类指令" class="headerlink" title="3.5.1 数据传送类指令"></a>3.5.1 数据传送类指令</h3><p>就是MOV</p>
<h4 id="一、数据传送指令-–-6种"><a href="#一、数据传送指令-–-6种" class="headerlink" title="一、数据传送指令 – 6种"></a>一、数据传送指令 – 6种</h4>

<h4 id="二、存储器访问指令"><a href="#二、存储器访问指令" class="headerlink" title="二、存储器访问指令"></a>二、存储器访问指令</h4><ul>
<li>功能：用于产生PC相关地址、处理器寄存器和存储器之间传送数据。</li>
<li>分类<ul>
<li>加载指令：将存储器中的数据传送到寄存器中</li>
<li>存储指令：将寄存器中的数据传送到存储器中</li>
</ul>
</li>
<li>特点：处理器对存储器的访问只能通过加载&#x2F;存储指令实现。</li>
<li><h2 id="具体六种"><a href="#具体六种" class="headerlink" title="具体六种"></a>具体六种</h2></li>
</ul>
<h4 id="1-数据运算指令"><a href="#1-数据运算指令" class="headerlink" title="1.数据运算指令"></a>1.数据运算指令</h4><p>就是RDR</p>
<h4 id="2-存储器访问指令"><a href="#2-存储器访问指令" class="headerlink" title="2.存储器访问指令"></a>2.存储器访问指令</h4><h3 id="3-5-2-数据运算类指令"><a href="#3-5-2-数据运算类指令" class="headerlink" title="3.5.2 数据运算类指令"></a>3.5.2 数据运算类指令</h3><h4 id="3-算术运算指令"><a href="#3-算术运算指令" class="headerlink" title="3.算术运算指令"></a>3.算术运算指令</h4><p>加减乘除</p>
<h4 id="4-逻辑运算指令"><a href="#4-逻辑运算指令" class="headerlink" title="4.逻辑运算指令"></a>4.逻辑运算指令</h4><p>与或非异或</p>
<h4 id="5-移位和循环指令"><a href="#5-移位和循环指令" class="headerlink" title="5.移位和循环指令"></a>5.移位和循环指令</h4><p>逻辑左移右移 循环移动</p>
<h4 id="6-符号扩展指令（展开指令）"><a href="#6-符号扩展指令（展开指令）" class="headerlink" title="6.符号扩展指令（展开指令）"></a>6.符号扩展指令（展开指令）</h4><h4 id="7-数据调序指令（字节交换指令）"><a href="#7-数据调序指令（字节交换指令）" class="headerlink" title="7.数据调序指令（字节交换指令）"></a>7.数据调序指令（字节交换指令）</h4><p>比如一个字当中的4个字节变换位置(字节交换)</p>
<h4 id="8-饱和运算指令"><a href="#8-饱和运算指令" class="headerlink" title="8.饱和运算指令"></a>8.饱和运算指令</h4><h3 id="3-5-3-位域处理类指令"><a href="#3-5-3-位域处理类指令" class="headerlink" title="3.5.3 位域处理类指令"></a>3.5.3 位域处理类指令</h3><h4 id="9-位处理指令"><a href="#9-位处理指令" class="headerlink" title="9.位处理指令"></a>9.位处理指令</h4><p>对某一个字节单独的位处理</p>
<h3 id="3-5-4-控制转移类指令"><a href="#3-5-4-控制转移类指令" class="headerlink" title="3.5.4 控制转移类指令"></a>3.5.4 控制转移类指令</h3><h4 id="10-子程序调用与无条件转移指令"><a href="#10-子程序调用与无条件转移指令" class="headerlink" title="10.子程序调用与无条件转移指令"></a>10.子程序调用与无条件转移指令</h4><h4 id="11-条件转移指令"><a href="#11-条件转移指令" class="headerlink" title="11.条件转移指令"></a>11.条件转移指令</h4><h4 id="12-隔离指令"><a href="#12-隔离指令" class="headerlink" title="12.隔离指令"></a>12.隔离指令</h4><h2 id="4-4-ARM汇编语言的程序结构"><a href="#4-4-ARM汇编语言的程序结构" class="headerlink" title="4.4 ARM汇编语言的程序结构"></a>4.4 ARM汇编语言的程序结构</h2><h3 id="4-4-1-汇编语言的程序格式"><a href="#4-4-1-汇编语言的程序格式" class="headerlink" title="4.4.1 汇编语言的程序格式"></a>4.4.1 汇编语言的程序格式</h3><p><img src="/.io//often/%25E8%25AF%25BE%25E7%25A8%258B%25E8%25B5%2584%25E6%2596%2599/Markdown/%25E5%258D%2595%25E7%2589%2587%25E6%259C%25BAARM/img/QQ%25E6%2588%25AA%25E5%259B%25BE20220919080950.png"></p>
<h3 id="4-4-2-汇编语言子程序调用"><a href="#4-4-2-汇编语言子程序调用" class="headerlink" title="4.4.2 汇编语言子程序调用"></a>4.4.2 汇编语言子程序调用</h3><ul>
<li>调用方法：BL子程序名</li>
<li>调用过程：返回地址存放在连接寄存器LR中，同时将程序计数器PC指向子程序的入口点。</li>
<li>调用返回：当子程序返回时，将存放在LR中的返回地址重新拷贝给程序计数器PC。</li>
<li>参数传递：R0-R3<br>- 最多传递4个，多出的要用堆栈处理</li>
<li>结果返回<ul>
<li>R0，返回32位数</li>
<li>R0，R1返回64位数 </li>
<li>….以此类推</li>
</ul>
</li>
</ul>
<p>比如：<br><img src="/.io//often/%25E8%25AF%25BE%25E7%25A8%258B%25E8%25B5%2584%25E6%2596%2599/Markdown/%25E5%258D%2595%25E7%2589%2587%25E6%259C%25BAARM/img/4-2.png"></p>
<h3 id="4-4-3-过程调用标准AAPCS"><a href="#4-4-3-过程调用标准AAPCS" class="headerlink" title="4.4.3 过程调用标准AAPCS"></a>4.4.3 过程调用标准AAPCS</h3><h4 id="二、ARM寄存器使用规则"><a href="#二、ARM寄存器使用规则" class="headerlink" title="二、ARM寄存器使用规则"></a>二、ARM寄存器使用规则</h4><ul>
<li>子程序间通过寄存器<strong>R0、R1、R2、 R3来传递参数</strong>。如果参数多于4个，则多出的部分用堆栈传递。被调用的子程序在返回前无需恢复寄存器R0-R3的内容。</li>
<li>在子程序中，使用寄存器<strong>R4-R11来保存局部变量</strong>．如果在子程序中使用到了寄存器R4-R11中的某些寄存器，子程序进入时必须保存这些寄存器的值，在返回前必须恢复这些寄存器的值；对于子程序中没有用到的寄存器则不必进行这些操作。在Thumb程序中，通常只能使用寄存器<strong>R4-R7来保存局部变量</strong>。</li>
</ul>
<p><img src="/.io//often/%25E8%25AF%25BE%25E7%25A8%258B%25E8%25B5%2584%25E6%2596%2599/Markdown/%25E5%258D%2595%25E7%2589%2587%25E6%259C%25BAARM/img/4-3%2520ARM%25E5%25AF%2584%25E5%25AD%2598%25E5%2599%25A8%25E4%25BD%25BF%25E7%2594%25A8%25E8%25A7%2584%25E5%2588%2599.png"></p>
<h3 id="4-4-4-scatter文件的使用"><a href="#4-4-4-scatter文件的使用" class="headerlink" title="4.4.4 scatter文件的使用"></a>4.4.4 scatter文件的使用</h3><ul>
<li>告知编译器地址信息的方法有两种<ul>
<li>使用命令行(简单的情况)</li>
<li>使用scatter文件</li>
</ul>
</li>
</ul>
<h4 id="scatter-file—-分散加载文件"><a href="#scatter-file—-分散加载文件" class="headerlink" title="scatter file—-分散加载文件"></a>scatter file—-分散加载文件</h4><p>分散加载区域分为两部分：加载区和执行区。每个加载区可以创建一个或多个执行区 。</p>
<p><img src="/.io//often/%25E8%25AF%25BE%25E7%25A8%258B%25E8%25B5%2584%25E6%2596%2599/Markdown/%25E5%258D%2595%25E7%2589%2587%25E6%259C%25BAARM/img/4-6%2520%25E4%25B8%2580%25E4%25B8%25AA%25E6%25A0%2587%25E5%2587%2586%25E7%259A%2584%25E5%2588%2586%25E6%2595%25A3%25E5%258A%25A0%25E8%25BD%25BD%25E6%2596%2587%25E4%25BB%25B6.png"></p>
<h3 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h3><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">分支程序设计</span><br><span class="line">已知<span class="number">32</span>位有符号数X存放在存储器的地址<span class="number">0x90010</span>中，要求实现：</span><br><span class="line">Y<span class="symbol">=X</span> （X〉<span class="number">=0</span>）或 Y=-X （X&lt;<span class="number">0</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R1</span>，= <span class="number">0x90010</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R2</span>，[<span class="built_in">R1</span>]</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>，<span class="number">#0</span></span><br><span class="line"><span class="keyword">CMP</span> <span class="built_in">R2</span>，<span class="built_in">R0</span>      <span class="comment">;比较</span></span><br><span class="line"><span class="keyword">SUBLT</span> <span class="built_in">R2</span>，<span class="built_in">R0</span>，<span class="built_in">R2</span><span class="comment">;小于0</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R2</span>，[<span class="built_in">R1</span>]</span><br><span class="line"><span class="symbol">END</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-6-6-汇编程序调用C程序"><a href="#4-6-6-汇编程序调用C程序" class="headerlink" title="4.6.6 汇编程序调用C程序"></a>4.6.6 汇编程序调用C程序</h4><p>下面是C语言定义的子程序函数，为汇编调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c + d + e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是汇编调用C语言子程序的程序段。假设程序进入f时，R0中的值为 i</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; int f(int i) &#123; return g(i, 2*i, 3*i, 4*i, 5*i); &#125;</span></span><br><span class="line"><span class="symbol">PRESERVE8</span> <span class="comment">; 预编译，8字节对齐，遵从AAPCS规则</span></span><br><span class="line"><span class="symbol">EXPORT</span> f <span class="comment">; 申明可以被其他文件调用的符号</span></span><br><span class="line"><span class="symbol">AREA</span> f, <span class="meta">CODE</span>, <span class="meta">READONLY</span></span><br><span class="line"><span class="symbol">IMPORT</span> g <span class="comment">; 声明外部C程序g()</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">lr</span>, [<span class="built_in">sp</span>, #-<span class="number">4</span>]! <span class="comment">; 保存返回地址 lr</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">R1</span>, <span class="built_in">R0</span>, <span class="built_in">R0</span> <span class="comment">; 计算2*i(第2个参数)，a = R0，b = R1</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">R2</span>, <span class="built_in">R1</span>, <span class="built_in">R0</span> <span class="comment">; 计算3*i(第3个参数)，c = R2</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">R3</span>, <span class="built_in">R1</span>, <span class="built_in">R2</span> <span class="comment">; 计算5*I ，e = 堆栈传递</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R3</span>, [<span class="built_in">sp</span>, #-<span class="number">4</span>]! <span class="comment">; 第五个参数通过堆栈传递</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">R3</span>, <span class="built_in">R1</span>, <span class="built_in">R1</span> <span class="comment">; 计算4*i(第4个参数)，d = R3</span></span><br><span class="line"><span class="keyword">BL</span> g <span class="comment">; **调用C程序**</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#4</span> <span class="comment">; 从堆栈中删除第5个参数</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">pc</span>, [<span class="built_in">sp</span>], <span class="number">#4</span> <span class="comment">; 返回</span></span><br><span class="line"><span class="symbol">END</span></span><br></pre></td></tr></table></figure>

<h1 id="第五章-ARM-Cortex-M3微处理器的体系构架-Contents-Contents"><a href="#第五章-ARM-Cortex-M3微处理器的体系构架-Contents-Contents" class="headerlink" title="第五章 ARM Cortex-M3微处理器的体系构架 Contents Contents"></a>第五章 ARM Cortex-M3微处理器的体系构架 Contents Contents</h1><h2 id="5-1-Cortex-M3微处理器的内部功能组成"><a href="#5-1-Cortex-M3微处理器的内部功能组成" class="headerlink" title="5.1 Cortex-M3微处理器的内部功能组成"></a>5.1 Cortex-M3微处理器的内部功能组成</h2><pre><code>    这部分知道就好
</code></pre>
<p><img src="/.io//often/%25E8%25AF%25BE%25E7%25A8%258B%25E8%25B5%2584%25E6%2596%2599/Markdown/%25E5%258D%2595%25E7%2589%2587%25E6%259C%25BAARM/img/5-1.png"></p>
<h3 id="一、框图中应用程序可访问的组件"><a href="#一、框图中应用程序可访问的组件" class="headerlink" title="一、框图中应用程序可访问的组件"></a>一、框图中应用程序可访问的组件</h3><p>NVIC - 嵌套向量控制器</p>
<h3 id="二、框图中用于调试的组件"><a href="#二、框图中用于调试的组件" class="headerlink" title="二、框图中用于调试的组件"></a>二、框图中用于调试的组件</h3><h3 id="三、Cortex-M3-的总线接口"><a href="#三、Cortex-M3-的总线接口" class="headerlink" title="三、Cortex-M3 的总线接口"></a>三、Cortex-M3 的总线接口</h3><h2 id="5-2-存储器系统"><a href="#5-2-存储器系统" class="headerlink" title="5.2 存储器系统"></a>5.2 存储器系统</h2><h3 id="5-2-1-存储器系统的功能概览"><a href="#5-2-1-存储器系统的功能概览" class="headerlink" title="5.2.1 存储器系统的功能概览"></a>5.2.1 存储器系统的功能概览</h3><ul>
<li><p>① Cortex-M3 只有一个单一固定的存储器映射。</p>
</li>
<li><p>② Cortex-M3的存储器映射是预定义的，并且规定好了哪个位置使用哪条总线。</p>
</li>
<li><p>③ Cortex-M3 的存储器系统支持所谓的位带——位寻址操作。通过它，可以实现对单一比特的原子操作。位带操作仅适用于一些特殊的存储器区域。</p>
<pre><code>不可分割、打断的操作
</code></pre>
</li>
<li><p>④ Cortex-M3 的存储器系统支持非对齐访问和互斥访问。这两个特性是直到了v7M 时才出来的。</p>
</li>
<li><p>⑤ Cortex-M3 的存储器系统支持小端配置和大端配置</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://rikumo-rinnku.github.io">Rikumo.Rinnku</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rikumo-rinnku.github.io/%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%94%E8%AE%B0/">http://rikumo-rinnku.github.io/%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rikumo-rinnku.github.io" target="_blank">璃雲の部屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E6%B0%B4%E5%A1%94.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/C++%20String%E7%B1%BB%E5%B8%B8%E7%94%A8%E2%80%94%E2%80%94%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E4%B8%8E%E6%B7%BB%E5%8A%A0/"><img class="prev-cover" src="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E6%B0%B4%E5%A1%94.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ String类常用——元素删除与添加</div></div></a></div><div class="next-post pull-right"><a href="/%E4%BC%A0%E6%84%9F%E5%99%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E6%B0%B4%E5%A1%94.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">雷达演讲资料收集</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E7%99%BD%E6%AF%9B%E5%90%B8%E8%A1%80%E9%AC%BC.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Rikumo.Rinnku</div><div class="author-info__description">瞎折腾</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/rikumo-rinnku"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.</span> <span class="toc-text">学习目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-number">1.2.</span> <span class="toc-text">预备知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-ARM%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.</span> <span class="toc-text">1.1 ARM概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-ARM-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.1.1  	ARM 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-ARM-%E7%9A%84RISC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.1.2  	ARM 的RISC体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-ARM-%E7%9A%84%E5%90%84%E7%A7%8D%E6%9E%84%E6%9E%B6%E7%89%88%E6%9C%AC"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.1.3  	ARM 的各种构架版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-ARM-%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%91%BD%E5%90%8D%E6%B3%95%E5%88%99"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.1.4  	ARM 处理器的命名法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-5ARM-%E7%9A%84%E5%90%84%E7%B3%BB%E5%88%97CPU"><span class="toc-number">1.3.5.</span> <span class="toc-text">1.1.5	ARM 的各系列CPU</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Cortex-M3%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.</span> <span class="toc-text">1.2 Cortex-M3概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1Cortex-M3%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.2.1	Cortex-M3处理器的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2Cortex-M3%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.2.2	Cortex-M3处理器的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3Cortex-M3%E5%8F%AF%E9%85%8D%E7%BD%AE%E7%9A%84%E9%80%89%E9%A1%B9"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.2.3	Cortex-M3可配置的选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4Cortex-M3%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">1.4.4.</span> <span class="toc-text">1.2.4	Cortex-M3指令集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ARM%E7%9A%84%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9C%89%E4%B8%89%E4%B8%AA"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">1) ARM的指令集有三个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Cortex-M3%E7%9A%84%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">2) Cortex-M3的指令集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Cortex-M3-%E4%B8%8E%E4%B8%89%E7%A7%8D%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">3) Cortex-M3 与三种指令集的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-STM32%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.</span> <span class="toc-text">1.3 STM32概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1STM32%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.3.1	STM32的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2STM32%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.3.2	STM32的命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3STM32F1%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.5.3.</span> <span class="toc-text">1.3.3	STM32F1的命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4STM32F1%E7%B3%BB%E5%88%97MCU%E5%88%86%E7%B1%BB%E4%B8%8E%E9%80%89%E5%9E%8B"><span class="toc-number">1.5.4.</span> <span class="toc-text">1.3.4	STM32F1系列MCU分类与选型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-5%E8%8A%AF%E7%89%87%E5%B0%81%E8%A3%85%E4%B8%8E%E7%AE%A1%E8%85%BF%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.5.5.</span> <span class="toc-text">1.3.5	芯片封装与管腿描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-6STM32F1%E7%B3%BB%E5%88%97MCU%E7%9A%84%E6%80%A7%E8%83%BD%E7%89%B9%E7%82%B9"><span class="toc-number">1.5.6.</span> <span class="toc-text">1.3.6	STM32F1系列MCU的性能特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-7STM32%E7%9A%84%E5%9B%BA%E4%BB%B6%E5%BA%93%E4%B8%8E%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">1.5.7.</span> <span class="toc-text">1.3.7	STM32的固件库与开发工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARM-CM3%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">ARM CM3的指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.2.</span> <span class="toc-text">2.2工作模式和访问权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E6%8F%90%E6%A6%82%E5%BF%B5-%E5%BC%82%E5%B8%B8"><span class="toc-number">2.2.1.</span> <span class="toc-text">一. 前提概念: 异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">二.两种工作模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E4%B8%A4%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%88%AB"><span class="toc-number">2.2.3.</span> <span class="toc-text">三.两种访问权限(特权级别)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.4.</span> <span class="toc-text">四. 工作模式与访问权限的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E3%80%81%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.</span> <span class="toc-text">2.3工作模式、访问权限的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E8%BD%AC%E6%8D%A2%E9%80%94%E5%BE%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">访问权限转换途径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">2.3.2.</span> <span class="toc-text">为什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">2.4数据类型与存储器格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">一. 数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%82%A8%E5%AD%98%E5%99%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">二. 储存器格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">1.概述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ARM-%E5%A4%84%E7%90%86%E5%99%A8%E9%BB%98%E8%AE%A4%E7%9A%84%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8%E5%99%A8%E6%A0%BC%E5%BC%8F%EF%BC%8C%E8%AE%BF%E9%97%AE%E4%BB%A3%E7%A0%81%E5%A7%8B%E7%BB%88%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%AB%AF%E6%A0%BC%E5%BC%8F%E3%80%82"><span class="toc-number">2.4.2.1.0.1.</span> <span class="toc-text">ARM 处理器默认的小端存储器格式，访问代码始终使用小端格式。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%A7%E3%80%81%E5%B0%8F%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">2.大、小端数据格式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">2.5寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8-R0-R15"><span class="toc-number">2.5.2.</span> <span class="toc-text">一. 通用寄存器 R0-R15</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8R13-SP"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">1. 堆栈指针寄存器R13(SP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%93%BE%E6%8E%A5%E5%AF%84%E5%AD%98%E5%99%A8R14%EF%BC%88LR%EF%BC%89"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">2. 链接寄存器R14（LR）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8R15%EF%BC%88PC%EF%BC%89"><span class="toc-number">2.5.2.3.</span> <span class="toc-text">3.程序计数器R15（PC）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.5.3.</span> <span class="toc-text">二. 特殊功能寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">2.5.4.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88PSRs-%E6%88%96xPSR%EF%BC%89"><span class="toc-number">2.5.5.</span> <span class="toc-text">一. 程序状态寄存器（PSRs 或xPSR）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8APSR"><span class="toc-number">2.5.5.1.</span> <span class="toc-text">1. 应用程序状态寄存器APSR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%AD%E6%96%AD%E5%8F%B7%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8IPSR"><span class="toc-number">2.5.5.2.</span> <span class="toc-text">2. 中断号程序状态寄存器IPSR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8EPSR"><span class="toc-number">2.5.5.3.</span> <span class="toc-text">3. 执行程序状态寄存器EPSR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-number">2.6.</span> <span class="toc-text">2.6异常与中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-number">2.7.</span> <span class="toc-text">2.7向量表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8%E5%A0%86%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">2.8.</span> <span class="toc-text">2.8堆栈操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9%E5%A4%8D%E4%BD%8D%E5%BA%8F%E5%88%97"><span class="toc-number">2.9.</span> <span class="toc-text">2.9复位序列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-ARM-Cortex-M3%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">第 3 章 ARM-Cortex-M3的指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Cortex-M3%E7%9A%84%E5%85%AB%E7%A7%8D%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">3.2 Cortex-M3的八种寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-number">3.1.1.</span> <span class="toc-text">1、寄存器寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80"><span class="toc-number">3.1.2.</span> <span class="toc-text">2、立即寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%BB%E4%BD%8D%E5%AF%BB%E5%9D%80"><span class="toc-number">3.1.3.</span> <span class="toc-text">3、寄存器移位寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">3.1.4.</span> <span class="toc-text">4、寄存器间接寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">3.1.5.</span> <span class="toc-text">5、基址寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%A4%9A%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-number">3.1.6.</span> <span class="toc-text">6、多寄存器寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80"><span class="toc-number">3.1.7.</span> <span class="toc-text">7、堆栈寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80"><span class="toc-number">3.1.8.</span> <span class="toc-text">8、相对寻址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Thumb-2-%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">3.3 Thumb-2 汇编程序结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Thumb-2%E6%8C%87%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3.4 Thumb-2指令基本格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%87%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">1.指令基本格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Cortex-M3%E5%B8%B8%E7%94%A8%E7%9A%84Thumb-2%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.</span> <span class="toc-text">3.5 Cortex-M3常用的Thumb-2指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.5.1 数据传送类指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4-%E2%80%93-6%E7%A7%8D"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">一、数据传送指令 – 6种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">二、存储器访问指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%85%AD%E7%A7%8D"><span class="toc-number">3.5.</span> <span class="toc-text">具体六种</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.0.1.</span> <span class="toc-text">1.数据运算指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.0.2.</span> <span class="toc-text">2.存储器访问指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.2 数据运算类指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">3.算术运算指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">4.逻辑运算指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%A7%BB%E4%BD%8D%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">5.移位和循环指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95%E6%8C%87%E4%BB%A4%EF%BC%88%E5%B1%95%E5%BC%80%E6%8C%87%E4%BB%A4%EF%BC%89"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">6.符号扩展指令（展开指令）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%8F%E6%8C%87%E4%BB%A4%EF%BC%88%E5%AD%97%E8%8A%82%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4%EF%BC%89"><span class="toc-number">3.5.1.5.</span> <span class="toc-text">7.数据调序指令（字节交换指令）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E9%A5%B1%E5%92%8C%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.1.6.</span> <span class="toc-text">8.饱和运算指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E4%BD%8D%E5%9F%9F%E5%A4%84%E7%90%86%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.3 位域处理类指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%BD%8D%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">9.位处理指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.3.</span> <span class="toc-text">3.5.4 控制转移类指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E4%B8%8E%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">10.子程序调用与无条件转移指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">11.条件转移指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E9%9A%94%E7%A6%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">12.隔离指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-ARM%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.</span> <span class="toc-text">4.4 ARM汇编语言的程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.6.1.</span> <span class="toc-text">4.4.1 汇编语言的程序格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8"><span class="toc-number">3.6.2.</span> <span class="toc-text">4.4.2 汇编语言子程序调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A0%87%E5%87%86AAPCS"><span class="toc-number">3.6.3.</span> <span class="toc-text">4.4.3 过程调用标准AAPCS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ARM%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">二、ARM寄存器使用规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-4-scatter%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.6.4.</span> <span class="toc-text">4.4.4 scatter文件的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#scatter-file%E2%80%94-%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">scatter file—-分散加载文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.6.5.</span> <span class="toc-text">程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-6-%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.6.5.1.</span> <span class="toc-text">4.6.6 汇编程序调用C程序</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-ARM-Cortex-M3%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%BD%93%E7%B3%BB%E6%9E%84%E6%9E%B6-Contents-Contents"><span class="toc-number">4.</span> <span class="toc-text">第五章 ARM Cortex-M3微处理器的体系构架 Contents Contents</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Cortex-M3%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%86%85%E9%83%A8%E5%8A%9F%E8%83%BD%E7%BB%84%E6%88%90"><span class="toc-number">4.1.</span> <span class="toc-text">5.1 Cortex-M3微处理器的内部功能组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A1%86%E5%9B%BE%E4%B8%AD%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">4.1.1.</span> <span class="toc-text">一、框图中应用程序可访问的组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A1%86%E5%9B%BE%E4%B8%AD%E7%94%A8%E4%BA%8E%E8%B0%83%E8%AF%95%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">4.1.2.</span> <span class="toc-text">二、框图中用于调试的组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Cortex-M3-%E7%9A%84%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.3.</span> <span class="toc-text">三、Cortex-M3 的总线接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.2.</span> <span class="toc-text">5.2 存储器系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A6%82%E8%A7%88"><span class="toc-number">4.2.1.</span> <span class="toc-text">5.2.1 存储器系统的功能概览</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E5%9B%BE%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="图的部分基础概念"><img src="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E6%B0%B4%E5%A1%94.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图的部分基础概念"/></a><div class="content"><a class="title" href="/%E5%9B%BE%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="图的部分基础概念">图的部分基础概念</a><time datetime="2025-01-14T16:00:00.000Z" title="发表于 2025-01-15 00:00:00">2025-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/C++%20String%E7%B1%BB%E5%B8%B8%E7%94%A8%E2%80%94%E2%80%94%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E4%B8%8E%E6%B7%BB%E5%8A%A0/" title="C++ String类常用——元素删除与添加"><img src="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E6%B0%B4%E5%A1%94.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ String类常用——元素删除与添加"/></a><div class="content"><a class="title" href="/C++%20String%E7%B1%BB%E5%B8%B8%E7%94%A8%E2%80%94%E2%80%94%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E4%B8%8E%E6%B7%BB%E5%8A%A0/" title="C++ String类常用——元素删除与添加">C++ String类常用——元素删除与添加</a><time datetime="2024-09-30T16:00:00.000Z" title="发表于 2024-10-01 00:00:00">2024-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%94%E8%AE%B0/" title="单片机笔记"><img src="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E6%B0%B4%E5%A1%94.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单片机笔记"/></a><div class="content"><a class="title" href="/%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%94%E8%AE%B0/" title="单片机笔记">单片机笔记</a><time datetime="2024-03-20T05:07:45.187Z" title="发表于 2024-03-20 13:07:45">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E4%BC%A0%E6%84%9F%E5%99%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/" title="雷达演讲资料收集"><img src="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E6%B0%B4%E5%A1%94.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="雷达演讲资料收集"/></a><div class="content"><a class="title" href="/%E4%BC%A0%E6%84%9F%E5%99%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/" title="雷达演讲资料收集">雷达演讲资料收集</a><time datetime="2024-03-20T05:03:17.787Z" title="发表于 2024-03-20 13:03:17">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/05%E6%A0%87%E9%A2%98%E6%A0%8F%E4%B8%8E%E8%8F%9C%E5%8D%95%E6%A0%8F/" title="05标题栏与菜单栏"><img src="https://picgo-1306174022.cos.ap-nanjing.myqcloud.com/often_img/%E6%B0%B4%E5%A1%94.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="05标题栏与菜单栏"/></a><div class="content"><a class="title" href="/05%E6%A0%87%E9%A2%98%E6%A0%8F%E4%B8%8E%E8%8F%9C%E5%8D%95%E6%A0%8F/" title="05标题栏与菜单栏">05标题栏与菜单栏</a><time datetime="2024-03-12T10:00:00.000Z" title="发表于 2024-03-12 18:00:00">2024-03-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Rikumo.Rinnku</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>